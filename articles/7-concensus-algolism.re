= コンセンサスアルゴリズム
#@#担当者:CryptoAge


こちらの章は

@<href>{http://docs.neo.org/en-us/basic/consensus/whitepaper.html}

@<href>{http://docs.neo.org/en-us/basic/consensus/consensus.html}

の一部を日本語訳し、補足を加えたものです。


== 用語一覧
 * Proof of Stake PoS - 障害許容のあるネットワークコンセンサスを使ったアルゴリズムの一種。

 * Proof of Work PoW - 障害許容のある計算能力を使ったアルゴリズムの一種。

 * Byzantine Fault BF - ノードは機能しつつも悪意を持って行動する失敗

 * Delegated Byzantine Fault Tolerance DBFT -  障害許容を保証したNEOブロックチェーンに実装されたコンセンサスアルゴリズム

 * View v - NEO DBFTのコンセンサス形成において使われるデータセット




== 概要
ブロックチェーンは分散型台帳システムで、デジタル資産の登録や発行、財産権証明書、クレジットポイントなどにに利用することができ、P2Pで決済やトランザクションを送ることを可能にします。ブロックチェーン技術はCryptography Mailing ListでSatoshi NakamotoによってBitcoinとして初めて提唱されました。Bitcoinの提唱以降e-cashなどたくさんのアプリケーションがブロックチェーン上で作られています。従来の中央集権的な社会においてブロックチェーンはオープンで改ざんが不可能であり、二重送金が防止でき、第三者に依存せずトラストレスに機能するという点で極めて革新的です。しかし、すべての分散型台帳がそうであるようにブロックチェーンもネットワークはの遅延、送信エラー、ソフトウェアのバグ、セキュリティループホール、悪質なハッカーによる攻撃など多くの問題に対処する必要があります。さらに、トラストレスな分散型であるがゆえに参加者の全員を信用することができません。つまり、悪意にあるノードが現れる危険性もあれば、利権を争ってデータの分裂も生まれる可能性があります。このような潜在的な欠陥に対処するためにブロックチェーン技術は、常にすべてのノードが承認した最新バージョンの台帳を全員が共有していることを保証する必要があり、さらに台帳を更新していくための効率的なコンセンサスメカニズムを必要とします。従来の障害許容メカニズムではこのような問題を完全に対処することができません。ユニバーサルな規模ですべての欠陥に対処できる策が必要です。ビットコインで採用されているProof-of-Work(PoW)メカニズムは上記であげた問題を見事に解決します。PoW使った方式はマジョリティーの計算能力が善良のノードによるものとすることで障害許容が保証されます。しかし、計算能力に依存するこのスキームではマイニングをする際に電力の大量消費やハードウエアの使用により非常に効率が悪いです。このような依存はPoWのネットワークに様々な制限をもたらし、特にスケーラビリティ問題は深刻な問題になっています。さらに、ビットコインマイナーの圧倒的ハッシュパワーの影響を受けないようにするために、新しく作られるブロックチェーンはビットコインと異なるハッシュアルゴリズムを見つける必要があります。例えばLitecoinはビットコインで使われているSHA256ではなくSCRYPTを採用しています。




== ビサンチン将軍問題(BFT)
ビサンチン将軍問題とは分散型台帳において昔から存在する問題の一つで、相互に通信しあう集団において、個々のプレイヤーに対して悪意のある人による攻撃や通信の故障によって偽りの情報が伝達される可能性がある場合に、全体として正しい合意形成を行えるかという問題である。ビサンチン障害許容メカニズム(BFT)は分散型台帳において生じるこのような欠陥に対する新しい解決策です。特にNEOで採用されているコンセンサスアルゴリズムdBFTはビサンチン障害許容メカニズムの中でも、パブリックブロックチェーン用に工夫が施されています。




== dBFT(Delegated Byzantine Fault Tolerant)

ブロックチェーン間のもっとも根本的な性質の違いの一つはどのようにして障害耐性を保証するかです。NEOはdBFTというコンセンサスアルゴリズムを採用しています。dBFTはDelegated Byzantine Fault Tolerantの頭文字をとったものであり、 大規模な議決権の代理行使を通じてコンセンサス形成をするビザンチン障害許容メカニズムです。dBFTは通常のBFTとは異なり、NEOトークン保持者による投票を通じて支持する代表者を選ぶことができます。deligatedと呼ばれる所以はこの議決権の代理行使の仕組みにあります。BFTアルゴリズムを通じて選ばれた代表者のグループはコンセンサス形成を行い、新しいブロックを生成します。dBFTコンセンサスアルゴリズムはこのようにしてPoSの特徴(NEO保持者はコンセンサスノードの採決を行う) を一部取り入れる一方、最小限のリソースを用いてネットワークをビサンチン将軍問題ような欠陥からシステムを守ります。NEOのネットワークにおける投票はリアルタイムで継続しています。このコンセンサスアルゴリズムは障害耐性に欠陥をもたらすことなく現在のブロックチェーンのおける性能やスケーラビリティ問題を対処することができます。


dBFTはn個のコンセンサスノードからなるシステムにおいてf = (n-1) / 3 までの障害許容を提供します。これはf =  (n-1) / 3 まで個の悪意のあるノードまでシステムは耐性があるということを意味します。このメカニズムはビサンチン将軍問題に耐性があり、可用性を含んでいるためどんなネットワーク環境にも適しています。dBFTは一度確認が済むとブロックは分岐することができなくなり、トランザクションは取り消されたり戻されたりしないのでファイナリティが高いと言えます。NEOのdBFTコンセンサスメカニズムでは、ブロックを生成するのに15〜20秒程度なのでトランザクションの処理数は毎秒1,000トランザクションにまで登ります。この数字はパブリックブロックチェーンにしては極めて高いです。例えばビットコインのブロックは10分に一度生成され、１ブロックは1MBが上限なため理論上毎秒処理できるトランザクションは6~7個です(実際は若干変動する)。さらにdBFTは最適化を通じて処理できるトランザクション数を毎秒10,000トランザクションにまで増加させるポテンシャルがあります。このように大量のトランザクションを処理できるシステムは大規模な商業にも応用できます。また、dBFTはデジタルアイデンティティ技術を取り入れており、記録者は実名や会社名を利用することができます。ゆえに、司法的決断によりフリーズ、取り消し、相続、 回復、権限の送付が可能となっています。これはNEOネットワークに金融資産を登録することを促進させます。




== システムモデル
ブロックチェーンとは分散型台帳システムであり、参加者はP２Pのネットワークを通じて繋がっており、メッセージは台帳に書き込まれていくように共有されます。一般にノードは二種類存在し一つは普通のノード、もう一つは記録ノードです。普通のノードは台帳のデータを受領しながら、情報の伝達や価値の移動の手段としてブロックチェーンを利用しています。一方記録ノードは経理のような業務を行う事で台帳を管理維持しています。ブロックチェーンをはじめとした分散型台帳システムではメッセージの消失や破損、遅延の繰り返しが考えられ、さらに送信した順番は必ずしも受信する順番と一致しないことが起こり得ます。また、ノードの行動は恣意的で自由にネットワークを出入りでき、時に誤った情報を流す事もあれば、急に機能しなくなることも想定されます。さらに、機械であろうが人間であろうがエラーは必ずつきものなってきます。このような問題に対処すべくブロックチェーンでは送信者がハッシュ値に署名ををすることによって情報の整合性や確実性は暗号学で保証します。今〈𝑚〉𝜎𝑖 を、ノードiからのメッセージmの電子署名だと定義し、またD(m)をメッセージmのハッシュ値だと定義します。 特別な断りがない限りすべての署名はがメッセージのハッシュ値への署名であるとします。


== 一般手順
通常時のブロック生成時間をtとするとアルゴリズムは以下の流れで実行されます。

1. ノードがトランザクションデータに署名をつけてネットワーク全体に伝達する。 

2. すべての記録ノードはトランザクションを各々で監視し、各自メモリーに保存する。 

3. 時間t経過後議長(スピーカー)は 〈𝑃𝑟𝑒𝑝𝑎𝑟𝑒𝑅𝑒𝑞𝑢𝑒𝑠𝑡,ℎ,𝑣,𝑝,𝑏𝑙𝑜𝑐𝑘,〈𝑏𝑙𝑜𝑐𝑘〉𝜎𝑝〉を送る 。

4. 提案を受けると議員 i が 〈𝑃𝑟𝑒𝑝𝑎𝑟𝑒𝑅𝑒𝑠𝑝𝑜𝑛𝑠𝑒,ℎ,𝑣,𝑖,〈𝑏𝑙𝑜𝑐𝑘〉𝜎𝑖〉を送る。

5. 受信したノード数が𝑛 − 𝑓 〈𝑏𝑙𝑜𝑐𝑘〉𝜎𝑖に到達するとコンセンサスが形成され完全なブロックが作られる。

6. 完全なブロックを受け取るとメモリー内のトランザクションを消し次のラウンドのコンセンサス形成を開始。

全てのコンセンサスノードにとって少なくとも𝑛 − 𝑓 個のノードが同じオリジナルの状態にいる必要があります。具体的には全てのノードiにとってブロック高hとViewの数字vは一致していないといけないということです。しかしこれを実現するのは非常に難しいです。hの値の共有はブロックを同期することで保つことができます。一方vの値の共有はViewを変更することで保つことができます。ブロックの同期はここでは扱いませんが、Viewの同期については次のセクションで扱うことにします。各ノードは伝達を監視し、提案の受領を見届けた後、トランザクションを検証します。一度提案が晒されてしまうとノードはメモリーに不正なトランザクションを新しく書くことができなくなります。もし不正なトランザクションが提案に初めから含まれていた場合、このラウンドのコンセンサス形成は断念され、Viewの値が直ちに変更されます。検証の過程は以下の通りである。

1.トランザクションデータのフォーマットがルールを守っているか?もしそうでなかったらトランザクションは不正である。

2.トランザクションはもうブロックチェーンにあるか?もしあればトランザクションは不正。 

3.トランザクションのコントラクトスクリプトがちゃんと実行されているか? もし実行できていなかったらトランザクションは不正。

4.トランザクション内に二重送金があるか?もしあればトランザクションは不正。

5.上記の過程でトランザクションが不正とみなされなかった場合, 正しいトランザクションとみなされる。


== Viewの変更
もし 2𝑣+1 ⋅ 𝑡回のインターバルの後コンセンサス形成ができない場合 、あるいは不正なトランザクションを含む提案を受領した時viewの値が変更されます。
k=1, 𝑣𝑘 = 𝑣 + 𝑘 とする。
ノードi が View変更リクエストを送る〈𝐶ℎ𝑎𝑛𝑔𝑒𝑉𝑖𝑒𝑤,ℎ,𝑣,𝑖,𝑣𝑘〉 。
どのノードからでも良いので少なくても𝑛 − 𝑓個の同じ vk を異なるiから受信すると、Viewの変更が完了する。𝑣 = 𝑣𝑘としコンセンサス形成が再び始まる。
もし 2𝑣+1 ⋅ 𝑡回のインターバルの後Viewの変更がなされない時 kが増加してステップ2に戻る。

kが増加すると全体の待ち時間が指数関数的に長くなる。したがって頻繁なViewの変更は避けられノードはコンセンサスを形成することが強いられます。 Viewの変更が完了する前にオリジナルのView vはまだ有効であるためネットワークの遅延などによる不必要なViewの変更が避けられます。


== フローチャート
//indepimage[consensus_flowchart][フローチャート][scale=1]




=== 役割
NEOのコンセンサスアルゴリズムではコンセンサスノードはNEO保有者の中から選ばれ、選ばれたものはトランザクションの正当性を判断し、投票を行います。このようなノードは上記で述べた記録ノードと同じノードを指します。以下では彼らをコンセンサスノードと呼ぶことにします。

//indepimage[nNode][コンセンサスノード][scale=0.1]

*  コンセンサスノード- このノードはコンセンサス形成に大きく関与する。コンセンサス形成時コンセンサスノードは以下の二つの役職に分かれる。

//indepimage[スピーカー (One)][scale=0.1]

*  スピーカー (One) - スピーカーはシステムにブロックの提案を行う。

//indepimage[代表者 (Multiple)][scale=0.1]

*  代表者 (Multiple) - 代表者はトランザクションのコンセンサス形成の責任を持つ


=== 理論
まずスピーカーの順序に従って必ずコンセンサス形成を行ういくつかの代表を決めます。 このシステムではスピーカーやどんな代表者も悪者になり得るので気をつけなければなりません。悪意のあるノードがいる場合の攻撃方法を色々検討して万全な障害耐性を整える必要があります。例えば悪意のあるノードは受信者に対してバラバラのメッセージを送るかもしれません。これは考えられる問題の中でももっとも深刻な問題です。この問題ん対処法はスピーカーが善良かどうかを代表者が見極め、グループとして正しく昨日するために必要な行動が何かを認識することです。dBFTが正しく機能するかを確かめるために66.66% consensus rateの検証を行う。ここで悪意のあるノードはアクティブに悪事を働くとは限らないことを頭に留めておかなければなりません。つまり突発的に善良なノードが悪意を持つようになるかもしれないということです。また善良なノードが過失的に誤って機能してしまう恐れもあります。以下ではコンセンサスアルゴリズムがうまく機能するかどうかを確かめるためにいくつかのシナリオを想定し、検証することにします。具体的にはnが小さい値のときの簡単な例における各ノードとスピーカー間のメッセージの送受信を想定します。このメカニズムはdBFTでも使われており、システムの中枢を担っています。今回はうまく機能する場合と機能しない場合のみを比較することにします。より詳細な説明は参照をご覧ください。

=== Honest Speaker

//indepimage[n3][n = 3で悪意のある代表者がいる時の例][scale=1]

図１では一つの善良な代表者(50%)がいる。両代表者は善良なスピーカーから同じメッセージを受け取る。しかし悪意のある代表者によって善良な代表者は悪意のある代表者がいることを確認することしかできず、それがスピーカーなのかもう一方の代表者かはわからない。
これにより代表者はViewを変更し、投票を拒みます。

//indepimage[n4][n = 4で悪意のある代表者がいる時の例][scale=1]

図２において２つの善良な代表者がいる(66%)。 全ての代表者は善良なスピーカーから同じメッセージを受信し、検証結果を他の代表者に送信する。二つの善良な代表者によるコンセンサス形成により私たちは、スピーカーか右の代表者が悪意があるとわかる。


=== Dishonest Speaker

//indepimage[g3][n = 3ので悪意のあるスピーカーがいる時の例][scale=1]
図３の場合の結論は図1に想定されるな結論がある。代表者はどのノードが悪意があるかはわからない。

//indepimage[g4][n = 4ので悪意のあるスピーカーがいる時の例][scale=1]
図４で示された例では真ん中と右のノードから受信したブロックは検証不可能である。これによって善良な代表者全体の66%を占めるため、viewが変更され、新しいスピーカーを採決する。この例において悪意のあるスピーカーが代表者の３分の２に正しいデータを送った場合、viewを変更することなく検証することができます。


== 実装
NEOのdBFTの実装は一定の善良な代表者のメッセージが一致するまで反復的にコンセンサス形成を行うメソッドによりコンセンサスが正しく形成されることを保証します。アルゴリズムのパフォーマンスはシステム内の善良なノード割合に依存します。図５は悪意のあるノードの割合の働きに応じて予想される反復を示します。図５は善良のノードの割合は66.66%を超えない場合を想定します。66.66%という決定的な値から33.33％までの間にはコンセンサス形成ができない'No-Man's Land'があります。33.33% 以下の場合は悪意のあるたちはノードはコンセンサス形成が可能になり、システム内で悪意のあるノードによる合意形成が”正しい”とみなされた情報として書き込まれることになります’。

//indepimage[consensus.intrations][Monto-CarloによるDBFTアルゴリズムのシミュレーション][scale=1]
各コンセンンサス形成に必要な反復数を示す{100 Nodes; 100,000 Simulated Blocks with random honest node selection}





== アルゴリズム

== 定義
アルゴリズムにおいて以下を定義する:

* t:ブロック生成に配分された時間(秒)
    * 現在: t = 15 seconds
    * この値はコンセンサス形成活動とコミュニケーションイベントが時間に顕著に関係していれば、一つのviewの反復の期間を近似するのに利用できる。
* n: アクティブなコンセンサスノードの数

* f: システム内における最小限の悪意のあるノード
    * f = (n - 1) / 3

* h :現在のブロック高

* i : コンセンサスノードインデックス

* v : コンセンサスノードのview。viewはノードがコンセンサス形成のラウンド内で受信した情報の集合を含む。これはすべの代表者による投票を含む。 (prepareResponse or ChangeView) 。

* k : view vのインデックス。コンセンサス形成アクティビティは複数のラウンドを要求できる。コンセンサス形成が失敗した時、kは１増加し、次のラウンドが始まる。

* p : スピーカによって選ばれたコンセンサスノードのインデックス。この計算メカニズムは一つのコンセンサスノードが独裁的に働くことを防ぐためである。
    * p = (h - k) mod (n)

* s: 安全なコンセンサスのthreshold。これを下回るとネットワークに欠陥が生じる。
    * s = ((n - 1) - f)

=== 必要事項
NEOではconsensus fault toleranceのために３つの主要な必要事項がある。:
1. s 個の代表者ノードはブロックがコミットされるようになる前にトランザクションのコンセンサス形成を行う必要がある。

2.悪意のあるコンセンサスノードは善良なコンセンサスノードに偽ったトランザクションをするように唆すことはできない。

3. コンセンサス形成アクティビティを始めるにあたって少なくともs個の代表者は同じ状態(h,k)でなければならない。

=== アルゴリズム概要
BFTはセキュリティとユーザビリティ両方をカバーします。BFTでは、合意形成にジョインしたノードの合計を 𝑛 = |𝑅| (Rはコンセンサスノードのセットを表す)とすると、悪意のあるノードが ⌊ (𝑛−1) / 3 ⌋以下の場合システムの安定性は確保されます。。 f をシステムが耐えられる悪意のあるノードの最大数とすると𝑓 = ⌊ (𝑛−1) / 3 ⌋ とおける。実際、台帳全体は記録ノードによって維持され、普通のノードはコンセンサス形成には関与しません。また、すべてのコンセンサスノードは最新の状態遷移を記録する必要があります。コンセンサスに使われる初めから現在までのデータセットをViewと呼びます。もしあるViewでコンセンサスを形成することができなければViewの変更が必要になります。私たちはそれぞれのViewを０から番号をつけて識別し、この番号はコンセンサスが取れるまで一つずつ増加します。n個のコンセンサスノードは0からn-1までの番号がつけられます。毎回コンセンサスを形成する際、あるノードが議長(スピーカー)をやり、そのほかのノードは議員の役割をします。議長(スピーカー)の番号pは以下のようなアルゴリズムによって決定します。仮に現在のブロック高をhとし、 𝑝 = (ℎ − 𝑣) 𝑚𝑜𝑑 𝑛とするとpの値は0 ≤ 𝑝 < 𝑛となります。ブロックは少なくとも記録するノードの𝑛 − 𝑓個の署名コンセンサス形成時に毎回生成されます。ブロックが生成されるとv=0にリセットされ、新しいコンセンサス形成のラウンドが始まります。

アルゴリズムは以下のようにして機能します。
1. コンセンサスノードはトランザクションをネットワーク全体に送信者の署名付きで伝達する。

//indepimage[consensus1][コンセンサスノードはトランザクションを受信しシステム全体に伝達する。][scale=1]


2. コンセンサスノードはトランザクションデータをローカルメモリーに記録する。 

3. コンセンサス形成の初めのview vは初期化されている。

4. スピーカが確認される。t秒待つ。 

//indepimage[consensus2][スピーカーが確認され、viewがセットされる。][scale=1]

5. スピーカーが提案を伝達する: <prepareRequest, h, k, p, bloc, [block]sigp> 

//indepimage[consensus3][スピーカーが代表者によるレビューのためにブロックの提案を作る。][scale=1]
　　　　
6. 代表者は提案を受信し検証する

    * データのフォーマットがシステムのルールと合致しているか。
    * トランザクションはすでにブロックチェーンに格納されているか
    * コントラクトのスクリプトは正しく実行されているか
    * トランザクションは二重送金になっていないか
    * もし正しく検証されれば <prepareResponse, h, k, i, [block]sigi>とネットワークに伝達する
    * もし正しく検証されなければ<ChangeView, h,k,i,k+1>とネットワークに伝達する


//indepimage[consensus4][代表者がブロック提案をレビューして返答する][scale=1]
　　　　　

7. s 個の'prepareResponse' の伝達を受信したのち、代表者はコンセンサスを形成し、ブロックを発行する。

8. 代表者はブロックにサインする。

//indepimage[consensus5][コンセンサスが形成され、賛同する代表者がブロックにサインしてブロックチェーンに格納する。][scale=1]


9. コンセンサスノードが完全なブロックを受信したとき、その時のviewのデータは一掃され、次のラウンドのコンセンサス形成が始まる。



== 障害耐性度　

BFTのアルゴリズムはn個のノードを含むコンセンサスシステムに 𝑓 = ⌊ (𝑛−1) / 3 ⌋の障害耐性を提供します。この障害耐性度はセキュリティとユーザビリティ含み、どんなネットワーク環境にも適しています。ノードからのリクエストデータは送信者の署名を含むので、悪意のある記録ノードは偽ってリクエストできません。その代わり、悪意のあるノードはシステムをフォークさせることで情報を過去のものに戻そうとします。仮にこのシステムのネットワークにおいてコンセンサスノードが３つの部分𝑅1 、 𝑅2 、 𝐹に分かれ、それぞれの間には𝑅 = 𝑅1 ∪ 𝑅2 ∪ 𝐹 、 𝑅1 ∩ 𝑅2 = ∅ 、 𝑅1 ∩ 𝐹 = ∅ 、𝑅2 ∩ 𝐹 = ∅が成り立つとします。さらに、R1とR2が善良な記録ノードで自分と同じセットにいるノードとしかコミュニケーションが取れないようなサイロにいるとします。そしてFは全て悪意のあるノードだとします。さらにFによるネットワークのコンディションによってFは𝑅1、𝑅2を含む全てのノードとコミュニケーションが取れるとします。もしFがフォークしようとするならばR1とコンセンサス形成を行い、ブロックを作ります。さらにFはR2にはこのことを知らせないままR2と次のコンセンサス形成を行い、R1とのコンセンサスを取り消します。 この状況に至るためには |𝑅1| + |𝐹| ≥ 𝑛 − 𝑓 and |𝑅2| + |𝐹| ≥ 𝑛 − 𝑓 が必要です。最悪のシナリオでは|𝐹| = 𝑓、 すなわちシステムが耐えられる悪意のあるノードの数が最大になるのは |𝑅1| ≥ 𝑛 − 2𝑓 と |𝑅2| ≥ 𝑛 − 2𝑓であり、全て合わせると |𝑅1| + |𝑅2| ≥ 2𝑛 − 4𝑓 すなわち𝑛 ≤ 3𝑓である。 つまり𝑓 = ⌊ (𝑛−1) / 3 ⌋であるとすると、システムはフォークされる事はないのです。
